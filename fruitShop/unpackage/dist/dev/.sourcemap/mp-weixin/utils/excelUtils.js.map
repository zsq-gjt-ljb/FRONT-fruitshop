{"version":3,"file":"excelUtils.js","sources":["utils/excelUtils.js"],"sourcesContent":["import * as XLSX from 'xlsx';\r\n\r\n/**\r\n * 解析压缩的Excel二进制数据并转换为JSON\r\n * @param {ArrayBuffer} compressedData 压缩的Excel文件二进制数据\r\n * @param {Object} options 解析选项\r\n * @returns {Object} 解析结果\r\n */\r\nexport const parseCompressedExcelData = (compressedData, options = {}) => {\r\n  if (!compressedData) {\r\n    console.error('无效的压缩数据');\r\n    return { error: '无效的压缩数据' };\r\n  }\r\n  \r\n  try {\r\n    // 将压缩的二进制数据转换为base64字符串\r\n    const base64Data = arrayBufferToBase64(compressedData);\r\n    \r\n    // 使用SheetJS直接解析，它支持解析压缩的Excel数据\r\n    // SheetJS可以自动检测并处理各种Excel格式，包括ZIP压缩过的\r\n    const workbook = XLSX.read(base64Data, { type: 'base64' });\r\n    \r\n    // 获取所有表名\r\n    const sheetNames = workbook.SheetNames;\r\n    if (sheetNames.length === 0) {\r\n      return { error: 'Excel文件中没有工作表' };\r\n    }\r\n    \r\n    // 确定要处理的工作表\r\n    let sheetName = options.sheetName;\r\n    if (!sheetName) {\r\n      const sheetIndex = options.sheetIndex || 0;\r\n      sheetName = sheetNames[sheetIndex] || sheetNames[0];\r\n    }\r\n    \r\n    // 获取指定工作表\r\n    const worksheet = workbook.Sheets[sheetName];\r\n    if (!worksheet) {\r\n      return { error: `找不到工作表: ${sheetName}` };\r\n    }\r\n    \r\n    // 将工作表转换为JSON对象\r\n    const jsonData = XLSX.utils.sheet_to_json(worksheet, {\r\n      header: options.header !== false ? 1 : undefined,\r\n      raw: true,\r\n      defval: ''\r\n    });\r\n    \r\n    // 返回解析结果\r\n    return {\r\n      sheets: sheetNames,\r\n      data: jsonData,\r\n      sheetName: sheetName\r\n    };\r\n  } catch (error) {\r\n    console.error('解析压缩Excel数据失败:', error);\r\n    return { error: '解析压缩Excel数据失败: ' + error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * 将ArrayBuffer转换为Base64字符串\r\n * @param {ArrayBuffer} buffer 要转换的ArrayBuffer\r\n * @returns {String} 转换后的Base64字符串\r\n */\r\nfunction arrayBufferToBase64(buffer) {\r\n  if (!buffer) {\r\n    return '';\r\n  }\r\n  \r\n  let binary = '';\r\n  const bytes = new Uint8Array(buffer);\r\n  const len = bytes.byteLength;\r\n  \r\n  for (let i = 0; i < len; i++) {\r\n    binary += String.fromCharCode(bytes[i]);\r\n  }\r\n  \r\n  // 小程序环境中使用wx.arrayBufferToBase64\r\n  if (typeof wx !== 'undefined' && wx.arrayBufferToBase64) {\r\n    return wx.arrayBufferToBase64(buffer);\r\n  }\r\n  \r\n  // 浏览器环境中使用btoa\r\n  if (typeof btoa !== 'undefined') {\r\n    return btoa(binary);\r\n  }\r\n  \r\n  // 如果以上方法都不可用，就使用自己实现的base64编码\r\n  return customBase64Encode(binary);\r\n}\r\n\r\n/**\r\n * 自定义base64编码实现（当wx.arrayBufferToBase64和btoa都不可用时）\r\n * @param {String} str 要编码的字符串\r\n * @returns {String} base64编码后的字符串\r\n */\r\nfunction customBase64Encode(str) {\r\n  // base64编码表\r\n  const b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n  let result = '';\r\n  let i = 0;\r\n  \r\n  do {\r\n    let a = str.charCodeAt(i++);\r\n    let b = str.charCodeAt(i++);\r\n    let c = str.charCodeAt(i++);\r\n    \r\n    a = a ? a : 0;\r\n    b = b ? b : 0;\r\n    c = c ? c : 0;\r\n    \r\n    const b1 = (a >> 2) & 0x3F;\r\n    const b2 = ((a & 0x3) << 4) | ((b >> 4) & 0xF);\r\n    const b3 = ((b & 0xF) << 2) | ((c >> 6) & 0x3);\r\n    const b4 = c & 0x3F;\r\n    \r\n    if (!b) {\r\n      b3 = b4 = 64;\r\n    } else if (!c) {\r\n      b4 = 64;\r\n    }\r\n    \r\n    result += b64chars.charAt(b1) + b64chars.charAt(b2) + b64chars.charAt(b3) + b64chars.charAt(b4);\r\n  } while (i < str.length);\r\n  \r\n  return result;\r\n}\r\n\r\n/**\r\n * 从接口获取压缩的Excel数据并解析为JSON\r\n * @param {Object} options 配置选项\r\n */\r\nexport const getCompressedExcelFromApi = (options) => {\r\n  if (!options.url) {\r\n    uni.showToast({\r\n      title: '接口地址不能为空',\r\n      icon: 'none'\r\n    });\r\n    return;\r\n  }\r\n  \r\n  // 显示加载中\r\n  uni.showLoading({\r\n    title: '正在获取数据...'\r\n  });\r\n  \r\n  // 请求接口获取压缩的Excel文件数据\r\n  uni.request({\r\n    url: options.url,\r\n    method: options.method || 'GET',\r\n    data: options.data || {},\r\n    header: {\r\n      ...options.header,\r\n      'content-type': 'application/json'\r\n    },\r\n    responseType: 'arraybuffer', // 重要：设置响应类型为arraybuffer\r\n    success: function(res) {\r\n      uni.hideLoading();\r\n      if (res.statusCode === 200) {\r\n        // 解析压缩的Excel数据\r\n        const result = parseCompressedExcelData(res.data, options);\r\n        if (result.error) {\r\n          uni.showToast({\r\n            title: result.error,\r\n            icon: 'none'\r\n          });\r\n          options.fail && options.fail(result.error);\r\n        } else {\r\n          options.success && options.success(result);\r\n        }\r\n      } else {\r\n        const errMsg = '获取数据失败: ' + res.statusCode;\r\n        uni.showToast({\r\n          title: errMsg,\r\n          icon: 'none'\r\n        });\r\n        options.fail && options.fail(errMsg);\r\n      }\r\n    },\r\n    fail: function(error) {\r\n      uni.hideLoading();\r\n      console.error('请求失败:', error);\r\n      uni.showToast({\r\n        title: '网络请求失败',\r\n        icon: 'none'\r\n      });\r\n      options.fail && options.fail(error);\r\n    },\r\n    complete: function() {\r\n      options.complete && options.complete();\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * 解析Excel二进制数据并转换为JSON\r\n * @param {ArrayBuffer} data Excel文件的二进制数据\r\n * @param {Object} options 解析选项\r\n * @param {String} options.sheetName 指定要读取的工作表名称\r\n * @param {Number} options.sheetIndex 指定要读取的工作表索引，默认为0\r\n * @param {Boolean} options.header 是否将第一行作为表头，默认为true\r\n * @returns {Object} 解析结果，包含sheets(所有表)和data(指定表的数据)\r\n */\r\nexport const parseExcelData = (data, options = {}) => {\r\n  if (!data || !(data instanceof ArrayBuffer)) {\r\n    console.error('无效的Excel数据');\r\n    return { error: '无效的Excel数据' };\r\n  }\r\n  \r\n  try {\r\n    // 将二进制数据转换为workbook对象\r\n    const workbook = XLSX.read(data, { type: 'array' });\r\n    \r\n    // 获取所有表名\r\n    const sheetNames = workbook.SheetNames;\r\n    if (sheetNames.length === 0) {\r\n      return { error: 'Excel文件中没有工作表' };\r\n    }\r\n    \r\n    // 确定要处理的工作表\r\n    let sheetName = options.sheetName;\r\n    if (!sheetName) {\r\n      const sheetIndex = options.sheetIndex || 0;\r\n      sheetName = sheetNames[sheetIndex] || sheetNames[0];\r\n    }\r\n    \r\n    // 获取指定工作表\r\n    const worksheet = workbook.Sheets[sheetName];\r\n    if (!worksheet) {\r\n      return { error: `找不到工作表: ${sheetName}` };\r\n    }\r\n    \r\n    // 将工作表转换为JSON对象\r\n    const jsonData = XLSX.utils.sheet_to_json(worksheet, {\r\n      header: options.header !== false ? 1 : undefined,\r\n      raw: true,\r\n      defval: ''\r\n    });\r\n    \r\n    // 返回解析结果\r\n    return {\r\n      sheets: sheetNames,\r\n      data: jsonData,\r\n      sheetName: sheetName\r\n    };\r\n  } catch (error) {\r\n    console.error('解析Excel数据失败:', error);\r\n    return { error: '解析Excel数据失败: ' + error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * 从接口获取Excel数据并解析为JSON\r\n * @param {Object} options 配置选项\r\n * @param {String} options.url 接口地址\r\n * @param {String} options.method 请求方法，默认为'GET'\r\n * @param {Object} options.data 请求参数\r\n * @param {Object} options.header 请求头\r\n * @param {Function} options.success 成功回调，参数为解析后的JSON数据\r\n * @param {Function} options.fail 失败回调，参数为错误信息\r\n * @param {Function} options.complete 完成回调\r\n */\r\nexport const getExcelFromApi = (options) => {\r\n  if (!options.url) {\r\n    uni.showToast({\r\n      title: '接口地址不能为空',\r\n      icon: 'none'\r\n    });\r\n    return;\r\n  }\r\n  \r\n  // 显示加载中\r\n  uni.showLoading({\r\n    title: '正在获取数据...'\r\n  });\r\n  \r\n  // 请求接口获取Excel文件数据\r\n  uni.request({\r\n    url: options.url,\r\n    method: options.method || 'GET',\r\n    data: options.data || {},\r\n    header: {\r\n      ...options.header,\r\n      'content-type': 'application/json'\r\n    },\r\n    responseType: 'arraybuffer', // 重要：设置响应类型为arraybuffer\r\n    success: function(res) {\r\n      uni.hideLoading();\r\n      if (res.statusCode === 200) {\r\n        // 解析Excel数据\r\n        const result = parseExcelData(res.data, options);\r\n        if (result.error) {\r\n          uni.showToast({\r\n            title: result.error,\r\n            icon: 'none'\r\n          });\r\n          options.fail && options.fail(result.error);\r\n        } else {\r\n          options.success && options.success(result);\r\n        }\r\n      } else {\r\n        const errMsg = '获取数据失败: ' + res.statusCode;\r\n        uni.showToast({\r\n          title: errMsg,\r\n          icon: 'none'\r\n        });\r\n        options.fail && options.fail(errMsg);\r\n      }\r\n    },\r\n    fail: function(error) {\r\n      uni.hideLoading();\r\n      console.error('请求失败:', error);\r\n      uni.showToast({\r\n        title: '网络请求失败',\r\n        icon: 'none'\r\n      });\r\n      options.fail && options.fail(error);\r\n    },\r\n    complete: function() {\r\n      options.complete && options.complete();\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * 创建一个新的Excel工作簿\r\n * @param {Array} data 数据数组\r\n * @param {Array} headers 表头数组，如 ['姓名', '年龄', '性别']\r\n * @param {String} sheetName 工作表名称，默认为'Sheet1'\r\n * @returns {Object} 工作簿对象\r\n */\r\nexport const createWorkbook = (data, headers, sheetName = 'Sheet1') => {\r\n  // 创建一个新的工作簿\r\n  const workbook = XLSX.utils.book_new();\r\n  \r\n  // 如果有表头，将其添加到数据的前面\r\n  let sheetData = [];\r\n  if (headers && headers.length > 0) {\r\n    sheetData.push(headers);\r\n  }\r\n  \r\n  // 添加数据\r\n  if (data && data.length > 0) {\r\n    sheetData = sheetData.concat(data);\r\n  }\r\n  \r\n  // 创建工作表\r\n  const worksheet = XLSX.utils.aoa_to_sheet(sheetData);\r\n  \r\n  // 将工作表添加到工作簿\r\n  XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);\r\n  \r\n  return workbook;\r\n};\r\n\r\n/**\r\n * 将工作簿导出为Excel文件并保存\r\n * @param {Object} workbook 工作簿对象\r\n * @param {String} fileName 文件名，默认为'export.xlsx'\r\n */\r\nexport const exportWorkbook = (workbook, fileName = 'export.xlsx') => {\r\n  try {\r\n    // 将工作簿导出为二进制数据\r\n    const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });\r\n    \r\n    // 将二进制数据保存为临时文件\r\n    const fs = uni.getFileSystemManager();\r\n    const tempFilePath = `${uni.env.USER_DATA_PATH}/${fileName}`;\r\n    \r\n    fs.writeFileSync(tempFilePath, wbout, 'binary');\r\n    \r\n    // 显示文件保存位置的提示\r\n    uni.showModal({\r\n      title: '文件已导出',\r\n      content: `文件已保存到：${tempFilePath}`,\r\n      confirmText: '打开文件',\r\n      cancelText: '关闭',\r\n      success: function(res) {\r\n        if (res.confirm) {\r\n          // 尝试打开文档\r\n          uni.openDocument({\r\n            filePath: tempFilePath,\r\n            showMenu: true,\r\n            success: function() {\r\n              console.log('文档打开成功');\r\n            },\r\n            fail: function(error) {\r\n              console.error('打开文档失败:', error);\r\n              \r\n              // 尝试保存到本地\r\n              uni.saveFile({\r\n                tempFilePath: tempFilePath,\r\n                success: function(saveRes) {\r\n                  const savedFilePath = saveRes.savedFilePath;\r\n                  \r\n                  uni.showModal({\r\n                    title: '文件已保存',\r\n                    content: `文件已永久保存到：${savedFilePath}`,\r\n                    confirmText: '我知道了',\r\n                    showCancel: false\r\n                  });\r\n                },\r\n                fail: function(saveError) {\r\n                  console.error('保存文件失败:', saveError);\r\n                  \r\n                  // 如果还是失败，提供分享选项\r\n                  uni.showModal({\r\n                    title: '无法直接打开文件',\r\n                    content: '您想要分享此文件到微信或保存到相册吗？',\r\n                    confirmText: '分享文件',\r\n                    cancelText: '取消',\r\n                    success: function(modalRes) {\r\n                      if (modalRes.confirm) {\r\n                        // 尝试使用分享功能\r\n                        uni.shareFileMessage({\r\n                          filePath: tempFilePath,\r\n                          success: function() {\r\n                            console.log('文件分享成功');\r\n                          },\r\n                          fail: function(shareError) {\r\n                            console.error('文件分享失败:', shareError);\r\n                            uni.showToast({\r\n                              title: '分享失败，请重试',\r\n                              icon: 'none'\r\n                            });\r\n                          }\r\n                        });\r\n                      }\r\n                    }\r\n                  });\r\n                }\r\n              });\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    return tempFilePath;\r\n  } catch (error) {\r\n    console.error('导出Excel失败:', error);\r\n    uni.showToast({\r\n      title: '导出Excel失败',\r\n      icon: 'none'\r\n    });\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * 将Excel数据通过API下载，用户可选择保存位置\r\n * @param {Object} options 选项\r\n * @param {Object} options.data 要导出的数据\r\n * @param {Array} options.headers 表头\r\n * @param {String} options.fileName 文件名，默认为'export.xlsx'\r\n * @param {Function} options.success 成功回调\r\n * @param {Function} options.fail 失败回调\r\n */\r\nexport const exportToUserSelectedLocation = (options) => {\r\n  try {\r\n    // 创建工作簿\r\n    const workbook = createWorkbook(\r\n      options.data,\r\n      options.headers,\r\n      'Sheet1'\r\n    );\r\n    \r\n    // 转换为二进制\r\n    const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });\r\n    \r\n    // 转换为Blob URL (小程序环境不支持，仅在H5环境下有效)\r\n    if (typeof window !== 'undefined' && window.Blob && window.URL) {\r\n      const blob = new Blob([wbout], { type: 'application/octet-stream' });\r\n      const url = URL.createObjectURL(blob);\r\n      \r\n      // 创建下载链接\r\n      const a = document.createElement('a');\r\n      a.href = url;\r\n      a.download = options.fileName || 'export.xlsx';\r\n      document.body.appendChild(a);\r\n      a.click();\r\n      \r\n      // 清理\r\n      setTimeout(() => {\r\n        document.body.removeChild(a);\r\n        URL.revokeObjectURL(url);\r\n      }, 100);\r\n      \r\n      options.success && options.success();\r\n      return;\r\n    }\r\n    \r\n    // 小程序环境下\r\n    // 保存临时文件\r\n    const fs = uni.getFileSystemManager();\r\n    const tempFilePath = `${uni.env.USER_DATA_PATH}/${options.fileName || 'export.xlsx'}`;\r\n    fs.writeFileSync(tempFilePath, wbout, 'binary');\r\n    \r\n    // 保存到本地文件\r\n    uni.saveFile({\r\n      tempFilePath: tempFilePath,\r\n      success: function(saveRes) {\r\n        const savedFilePath = saveRes.savedFilePath;\r\n        \r\n        // 直接打开文件\r\n        uni.openDocument({\r\n          filePath: savedFilePath,\r\n          showMenu: true,\r\n          success: function() {\r\n            uni.showToast({\r\n              title: '文件已打开',\r\n              icon: 'success'\r\n            });\r\n            options.success && options.success(savedFilePath);\r\n          },\r\n          fail: function(error) {\r\n            console.error('打开文件失败:', error);\r\n            uni.showToast({\r\n              title: '文件已保存，但无法打开',\r\n              icon: 'none'\r\n            });\r\n            options.success && options.success(savedFilePath);\r\n          }\r\n        });\r\n      },\r\n      fail: function(error) {\r\n        console.error('保存文件失败:', error);\r\n        \r\n        // 如果保存失败，尝试直接打开临时文件\r\n        uni.openDocument({\r\n          filePath: tempFilePath,\r\n          showMenu: true,\r\n          success: function() {\r\n            uni.showToast({\r\n              title: '文件已打开',\r\n              icon: 'success'\r\n            });\r\n            options.success && options.success(tempFilePath);\r\n          },\r\n          fail: function(openError) {\r\n            console.error('打开文件失败:', openError);\r\n            uni.showToast({\r\n              title: '导出失败，请重试',\r\n              icon: 'none'\r\n            });\r\n            options.fail && options.fail(error);\r\n          }\r\n        });\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('导出Excel失败:', error);\r\n    uni.showToast({\r\n      title: '导出Excel失败',\r\n      icon: 'none'\r\n    });\r\n    options.fail && options.fail(error);\r\n  }\r\n}; "],"names":["uni","XLSX.read","XLSX.utils","XLSX.write"],"mappings":"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"}